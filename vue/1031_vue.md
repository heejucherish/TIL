#### vue

SPA

- SPA 는 서버에서 최초 1장의 HTML만 전달받아 모든 요청에 대응하는 방식
  - 어떻게 한 페이지로 모든 요청에 대응할 수있을까?
    - CSR (Client Side Rendering ) 방식으로 요청을 처리하기 때문

- 기존 방식은 전부 SSR 방식이었음 
  - 서버가 모든걸 다 만들고 서버가 렌더링 한다는 듯 

- 하지만 이제는 화면을 만드는 주체가 클라이언트로 넘어가게 됨 

  - 최초 한장의 HTML을 받아오는것은 동일

  - 이제 그리는건 클라이언트가 

  - 자바스크립트를 사용하여 필요한 부분만 다시 렌더링 

    1. AJAX 로 요청
    2. JSON 방식으로 전달
    3. jacascript로 처리 

  - 이제 서버는 데이터만 준다 ! 

    - ajax request 들어올 시에 

  - **왜 csr 방식을 사용하는 걸까?**

    - 장점
      - 모든 HTML 페이지를 서버로 부터 받아서 표시하지 않아도 된다
        - 클라이언트-서버간 통신/ 트래픽 감소
        - 응답 속도가 빨라진다. 
      - 매번 새 문서를 받아 새로고침 하는것이 아니라 필요한 부분만 고쳐 나가므로 요청이 끊임없이 진행
        - 요청이 자연스럽게 진행됨 UX 향상
      - BE와 FE의 작업 영역을 명확히 분리할 수 있다. 
        - 각자 맡은 역할을 명확히 분리 가능하다. 협업 용이 

    - 단점

      - 첫 구동시 필요한 데이터가 많으면 많을수록 최초 작동 시작까지 오랜시간이 소요된다. 
      - Naver, Netflix, 디즈니 플러스 등 모바일에 설치된 웹앱을 실하게되면 잠깐의 로딩시간이 필요
        - 그래서 로고로 보여줌 

    - csr은 만능일까?

      - 검색엔진 최적화 

      - SEO

        - 검색엔진에 노출되도록 개선하는 과정을 일컽는 작업 

        - CSR은 한번에 노출되기 어렵다 

          

    - CSR VS SSR 
      - 적재적소에 사용가능 해야함
      - SPA 서비스에서도 SSR을 지원하는 프레임워크가 발전하고있음
        - Vue의 Nuxt.js
        - 리액트 next.js
        - 앵큘러 유니버셜 등

- vue 의 구조

  - template - script - style 

- MVVM Pattern

  - ViewModel
    - dom listenners
    - directives 
  - View - 우리 눈에 보이는 부분 = DOM!
  - Model - 실제 데이터 = JSON!
  - VIEW  Model
    - view를 위한 모델
    - 뷰와 연결되어 액션을 주고받음
    - 모델이 변경되면 뷰 모델도 변경되고 바인딩된 뷰도 변경 
    - 뷰에서 사용자가 데이터를 변경하면 뷰 모델의 데이터가 변경되고 바인딩된 다른 뷰도 반영
  - MVC 패턴에서 컨트롤러를 제외하고 뷰 모델을 넣은 패턴
  - 뷰는 모델을 모르고, 모델도 뷰를 모른다. 
    - 둘이 독립적이다. 직접적으로 연결되어있지않다. 
    - 뷰랑 모델은 직접 소통 불가 

  - ==생성자 함수==
    - 대문자로 시작
    - new로 시작

  - ==el==
    - 뷰 인스턴스와 돔을 연결해주는 옵션 
      - 뷰와 모델을 연결하는 역할
      - httml id 혹은 class와 마운트 가능 
    - 뷰 인스턴스와 연결되지 않은 돔 외부는 뷰 의 영향을 받지 않음 
      - 뷰 속성 및 메서드를 사용할 수 없다. 
    - #app : id가 app인 엘리먼트를 연결하겠다 라는 뜻 
  - ==data==
    - 뷰 인스턴스의 데이터 객체 혹은 인스턴스 속성
    - 데이터 객체는 반드시 기본 객체 {} object 여야 함
    - 객체 내부의 아이템들은 value로 모든 타입의 객체를 가질 수 있음
    - 정의된 속성은 interpolation {{}}을 통해 view에 랜더링 가능함 
    - 추가된 객체는 this.message 형태로 접근 가능
  - ==methods== > 철자 주의...! 
    - this 는 객체를 가리킨다. 
    - this.$data.message 
      - 정해진 값에 접근할때는 저렇게 $로 접근해야하지만 $data 생략 가능 
      - this.message 로 가능! 
    - 메서드를 정의할때 arrow fuction을 사용하면 안됨 
    - arrow fuction의 this는 함수가 선언될 때 상위 스코프 윈도우를 가리키게 됨 
    - 호출은 문제 없이 가능한데 this로 뷰의 데이터 변경이 불가 

- Template syntax 

  - 렌더링 돔을 기본 인스턴스의 데이터에 선언적으로 바인딩 할수있는 html 기반 템플릿 문법을 사용한다 
    - 선언적으로 바인딩: 뷰 인스턴스와 돔을 연결 

- directives

  - v-show vs v-if

  - ==v-for== 

    - :key=
      - 특수 속성
      - ==v-for 사용시 반드시 key 속성을 각 요소에 작성==
      - key가 중복되어서는 안됨 
      - 
    - ==(value, key) in myObj== 
      - 위치 주의! 

  - ==v-on==

    - 이친구 이벤트 리스너
    - v-on:click
      - 약어 ==@click==
      - 보통 다 약어로 씀
        - @keyup.click 
    - : 을 통해 전달받은 인자를 확인 
      - v-on:keyup.enter 
    - 대기하고 있던 이벤트가 발생하면 할당된 표현식 실행 

  - ==v-bind==

    - : 뒤에 속성값을 자바스크립트의 표현식으로 값 넣어주기 

    - 약어 : 

      

  - ==v-model==
    - 양방향 바인딩
  - computed
    - method랑 차이
      - method는 같은 결과여도 매번 새롭게 계산 
    - method() computed는 그냥 씀 
    - method는 매번 호출
    - computed는 데이터 변동시에만 한번 계산 

  - watch

    - 감시자

    - 특정 데이터 변화를 감지하는 기능
    - 인자 순서
    - 첫번째 val 현재값
    - 두번째 과거값 
    - (현재값, 과거값 )