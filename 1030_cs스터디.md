#### 메모리 관리 전략

- 교착상태란?
  - 교착상태는 상호 배제에 의해 나타나는 문제점으로, 둘이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상을 의미합니다.
  
  - 교통 체증을 생각하면 됨. 자동차들이 현재 위치한 길을 점유함과 동시에 다른 차가 사용하는 길을 사용하려고 대기하고 있지만 다른 길을 사용 할 수 없으며 현재 길에서도 벗어나지 못하는 상태
  
  - 프로세스가 자원을 얻지 못해 다음 처리르 하지 못하는 상태를 말하며, 시스템적으로 한정된 자원을 여러곳에서 사용하려고 할때 발생하는 문제입니다. 
  
    
  
- 교착상태 4가지 조건
  - 아래 4가지 조건이 모두 충족 되어야 하며, 하나라도 충족되지 않으면 교착 상태가 발생하지 않는다. 
    - 상호 배제 : 한번에 한개의 프로세스만이 공유 자원을 사용할 수 있어야 한다.
    - 점유와 대기 : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다립니다.  
    - 비선점 : 다른 프로세스에 할당된 자원은 사용이 끝날때까지 강제로 빼앗을 수 없어야 합니다.
    - 순환 대기 : 공유자원과 공유자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 합니다. 
  - 하지만 순환 대기는 점유대기와 비선점을 모두 만족해야 성립합니다. 따라서 4가지가 독립적인건 아니다. 
  
- 교착상태 피하는/ 보완하는 방법(추가 공부 필요)
  - 예방기법
  
  - 회피 기법
    - 은행원 알고리즘
    
  - 발견 기법
  
  - 회복 기법
    - 프로세스 종료
    
    - 자원 선점 
    
      
  
- 외부 단편화와 내부 단편화란?
  - 외부 단편화란 남아있는 총 메모리 공간이 요청한 메모리 공간보다 크지만, 남아있는 공간이 연속적이지 않아 발생하는 현상입니다. 
    - 외부단편화 해결 방법 - 압축기법
      - 주기억장치 내 분산되어 있는 단편화 된 공간을 통합하여 하나의 커다란 빈 공간을 만드는 작업을 의미합니다. 
    
  - 내부 단편화란 주기억장치 내 사용자 영역이 실행 프로그램보다 커서 프로그램의 사용 공간을 할당 후 사용되지 않고 남게 되는 현상을 말한다. 
  
    
  
- 메모리 단편화 문제 해결방법 

  - 페이징 기법 - 가상메모리 사용 , 외부 단편화 해결, 내부 단편화 존재

    페이지 단위로 논리-물리 주소 관리 기법입니다. 논리 주소 공간이 하나의 연속적인 물리 메모리 공간에 들어가야하는 제약을 해결하기 위한 기법이며, 논리 주소 공간과 물리 주소 공간을 분리해야하고, 변환을 위한 MMU가 필요합니다. 

    - 장점
  
      1. 외부 단편화 문제 해결
      2. 페이지 공유 가능 : 메모리 공간의 효과적 활용
      3. 페이지 보호 가능

    - 단점

      1. 페이지 테이블 사용으로 분할 방식 대비 주소 결속으로 오버헤드 발생 : 속도 저하

      2. 페이지가 클수록 내부 단편화는 심해집니다. 

          
      
  
  - 세그멘테이션 기법 - 가상메모리 사용, 내부 단편화 해결, 외부 단편화 존재 
  
    - 사용자/프로그래머 관점의 메모리 관리 기법이며, 페이징 기법은 같은 크기의 페이지를 갖는 것과는 다르게 논리적 단위(세그먼트)로 나누므로 미리 분할하는것이 아니고 메모리 사용할 시점에 할당됩니다. 
  
  - 메모리 풀 
  
    - 필요한 메모리 공간을 필요한 크기, 개수만큼 사용자가 직접 지정하여 미리 할당 받아 놓고 필요할 때마다 사용하고 반납하는 기법입니다.  
    - 메모리 할당, 해제가 잦은 경우에 메모리 풀을 사용하면 효과적이다.
    - 미리 할당해놓고 사용하지 않는 순간에도 계속 할당해놓으므로 메모리 누수가 있는 방식임 



#### 가상메모리

- 가상메모리란?
  - 메모리에 로드된 실행 중인 프로세스가 메모리가 아닌 가상의 공간을 참조해 마치 커다란 물리 메모리를 갖는 것처럼 사용할 수있게 해주는 기법입니다. 

- 가상 메모리의 역할은 무엇일까요?

  1. 프로세스에서 실제 메모리 주소를 주는 대신 가상의 메모리 주소를 주는 것입니다.
  2. 가상 메모리는 실제 존재하는 물리 메모리와 사용자 프로세스의 논리 메모리 개념을 분리시킵니다. 
  3. 보조 저장 장치를 마치 RAM 처럼 활용할 수 있습니다. 

- 요구페이징에 대해 설명하시오

  - 요구페이징은 cpu가 요청할 때 프로세스의 데이터를 메모리에 올리는 것을 의미합니다. 즉 처음부터 모든 데이터를 메모리로 적재하지 않습니다. 

- cache 메모리를 사용하는 이유에 대해 설명하세요 

  - 먼저 캐시 메모리란 처리 속도가 다른 두 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리 입니다. 
  - 만일 캐시가 존재하지 않는다면 RAM에서 데이터를 인출해오는 속도가 CPU가 태스크를 처리하는 속도보다 느리기 때문에 불필요하게 시간을 낭비해야하지만, 실제로는 중간에 위치한 캐시메모리가 둘 사이에서 데이터를 고속으로 전달해줌으로써 속도 차이로 인한 병목을 어느정도 해결해 줄 수 있습니다. 

  - 단점
    - 처리속도가 굉장히 빠른 대신 용량이 작고 비싸다는 치명적인 약점이 존재합니다. 

#### 커널

- 커널 이란?
  - 커널은 운영체제 중 항상 메모리에 올라가 있는 운영체제의 핵심 부분으로써 하드웨어와 응용 프로그램 사이에서 인터페이스를 제공하는 역할을 하며 컴퓨터 자원들을 관리하는 역할을 한다.
  
  - 커널은 인터페이스로써 응용 프로그램 수행에 필요한 여러가지 서비스를 제공하고, 여러가지 하드웨어 등의 리소스를 관리하는 역할을 한다. 
  
    
  
- 커널 수준 스레드와 사용자 수준 스레드의 각각 장단점?

  - 커널 수준 스레드는 스레드 패키지를 운영체제에서 관리하며, 각 응용 프로그램들은 운영체제에 영향을 많이 받게 되므로 이식성이 낮습니다. 

    - 장점
      - 구현이 쉽고, 독자적인 알고리즘이 필요없습니다
    - 단점
      - 문맥 교환이 많이 일어나므로 속도가 느립니다
      - 때문에 대형 시스템에 부적합 합니다.

  - 사용자 수준의 스레드는 스레드 패키지를 사용자 영역에 두고 운영체제 커널은 단일 프로세스만을 관리합니다. 

    - 장점
      - 문맥 교한이 적으므로 속도가 빠릅니다. 
    - 단점
      - 구현이 어려우며, CPU사용을 해제하지 못하면 시스템이 중단됩니다. 

    

- 인터럽트가 필요한 이유 및 언제 발생되는지 말해주세요

  - CPU가 프로그램을 실행하고 있을때, 입/출력 장치나 혹은 다른 예외 상황이 발생하여 처리가 필요할 경우에 CPU에 알려서 처리를 하기 할때 인터럽트가 발생합니다.  

  - 필요한 이유

    - 입출력 연산은 CPU 명령 수행 속도보다 현저히 느리기 때문에, 상대적으로 속도가 너무 느린 입출력 연산을 CPU가 기다리게 된다면 효율이 너무 떨어지게 됩니다. 그래서 운영체제는 인터럽트로 연산 결과가 나올때까지 CPU에 다른 일을 수행하도록 하고, 연산 작업이 끝나면 작업 완료를 알려 CPU가 다시 해당 작업을 이어서 할 수 있도록 합니다. 즉, CPU 수행능력을 극대화 하는데 꼭 필요한 기능입니다. 

      

- 시스템콜이란 무엇이며 시스템 콜을 사용하는 예시는?

  - 시스템 콜이란 운영체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스 입니다.  보통 C나 C++과 같은 고급 언어로 작성된 프로그램들은 직접 시스템 호출을 사용 할 수 없기 때문에 고급 API를 통해 시스템 호출에 접근하게 하는 방법입니다. 

  - 일반적으로 윈도우 운영체제라면 마우스가, 리눅스라면 키보드가 사용자로 부터 입력을 받는데, 다음`cp in.txt out.txt`  명령어에서 in.txt 파일을 접근할 수 있는지 검사하기 위해 시스템 콜을 호출합니다. 만약 파일이 존재하지 않는다면 에러발생, 종료 할 때도 시스템 콜이 사용됩니다

    

- 서브루틴과 시스템 콜의 차이점은?

  - 서브루틴은 우리가 프로그래밍 할때 사용하는 대부분의 API를 이야기 하는 것입니다. 
  - 서브루틴이 시스템 콜을 호출하며, 시스템 콜이 수행한 결과를 서브루틴으로 보냅니다. 
  - 즉 시스템 콜 호출시 커널이 호출되며, 커널이 수행한 임의의 결과 데이터를 다시 시스템 콜로 보냅니다.
  - 그리고 다시 시스템 콜이 수행한 결과를 서브 루틴으로 보냅니다. 
  - 하지만 실무로 사용할 때는 둘의 큰 차이는 없습니다.  API 를 호출해서 사용하는것을 동일합니다. 