#### 메모리 관리 전략

- 교착상태란?
  - 교착상태는 상호 배제에 의해 나타나는 문제점으로, 둘이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상을 의미합니다.
  
  - 교통 체증을 생각하면 됨. 자동차들이 현재 위치한 길을 점유함과 동시에 다른 차가 사용하는 길을 사용하려고 대기하고 있지만 다른 길을 사용 할 수 없으며 현재 길에서도 벗어나지 못하는 상태
  
  - 프로세스가 자원을 얻지 못해 다음 처리르 하지 못하는 상태를 말하며, 시스템적으로 한정된 자원을 여러곳에서 사용하려고 할때 발생하는 문제입니다. 
  
    
  
- 교착상태 4가지 조건
  - 아래 4가지 조건이 **모두 충족** 되어야 하며, 하나라도 충족되지 않으면 교착 상태가 발생하지 않는다. 
    - 상호 배제 : 한번에 한개의 프로세스만이 공유 자원을 사용할 수 있어야 한다.
    - 점유와 대기 : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다립니다.  
    - 비선점 : 다른 프로세스에 할당된 자원은 사용이 끝날때까지 강제로 빼앗을 수 없어야 합니다.
    - 순환 대기 : 공유자원과 공유자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 합니다. 
    
  - 하지만 순환 대기는 점유대기와 비선점을 모두 만족해야 성립합니다. 따라서 4가지가 독립적인건 아니다. 
  
    
  
- 교착상태 피하는/ 보완하는 방법(추가 공부 필요)
  - 예방기법
  
    - 교착상태 예방 기법은 교착상태가 발생하지 않도록 사전에 시스템을 제어하는 방법으로 **교착상태 발생의 네 가지 조건 중에서 어느 하나를 부정함**으로써 수행되지만 **자원의 낭비가 매우 심하다. 이런 방식으로 교착상태를 예방하게 되면 장치의 이용률이 저하되고 시스템 이용률이 감소된다.**
  
    - 점유 및 대기 부정
      - 프로세스가 실행되기 전 필요한 모든 자원을 할당하여 프로세스 대기를 없애거나 자원이 점유되지 않은 상태에서만 자원을 요구하도록 합니다. 
  
      - 자원 이용률이 낮고 기아상태가 발생할 수 있습니다
  
    - 비선점 부정
      - 자신이 점유하고 있는 자원을 강제로 방출시켜 다른 프로세스가 선점하게 함으로써 교착상태를 없애버리는 방법이다
  
      - 처음부터 진행해야하는 단점
  
    - 순환대기 부정
      - 자원을 선형 순서로 분류하여 고유번호를 할당하고, 각 프로세스는 현재 점유한 자원의 고유 번호보다 앞이나 뒤 어느 한쪽 방향으로만 자원을 요구하도록 하는 것이다. 
  
    - 상호 배제 부정
      - 한번에 여러개의 프로세스가 공유자원을 사용할 수 있도록 합니다. 
  
  - 회피 기법
    - 은행원 알고리즘
      - 프로세스가 자원을 요구할때 시스템은 자원을 할당한 후에도 안정 상태로 남아 있게 되는지를 사전에 검사하여 교착상태를 회피하는 기법입니다. 
  
  - 발견 기법
  
    - 교착상태 발견 기법은 시스템에 교착상태가 발생했는지 점검해 교착상태에 있는 프로세스와 자원을 발견하는 것이다.
  
      **교착상태 발견 알고리즘과 자원 할당 그래프 등을 사용할 수 있다.**
  
  - 회복 기법
    - 프로세스 종료
  
      - 교착상태의 프로세스를 모두 중지 
  
    - 자원 선점 
  
      - 교착상태의 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에게 할당하며, 해당 프로세스를 일시 정지 시키는 방법 
      - 우선순위가 낮은 프로세스, 수행된 횟수가 적은 프로세스 등을 위주로 프로세스의 자원을 선점합니다. 
  
      
  
- 외부 단편화와 내부 단편화란?
  - **외부 단편화란** 남아있는 총 메모리 공간이 요청한 메모리 공간보다 크지만, 남아있는 공간이 연속적이지 않아 발생하는 현상입니다. 
    
    - 외부단편화 해결 방법 - 압축기법
      - 주기억장치 내 분산되어 있는 단편화 된 공간을 통합하여 하나의 커다란 빈 공간을 만드는 작업을 의미합니다. 
    
  - **내부 단편화란** 주기억장치 내 사용자 영역이 실행 프로그램보다 커서 프로그램의 사용 공간을 할당 후 사용되지 않고 남게 되는 현상을 말한다. 
  
    
  
- 메모리 단편화 문제 해결방법 

  - 가상메모리를 이용하여 내부 단편화 기법을 해결하는 세그멘테이션과 외부 단편화를 해결하는 페이징 기법이 있습니다.
    - Segmentation은 메모리를 서로 크기가 다른 논리적인 블록 단위인 세그먼트로 분할하여 메모리를 할당하는 기법입니다.
    - Paging은 프로세스를 일정 크기인 페이지로 잘라서 메모리에 적재하는 방식입니다.

  
  
  
  - **페이징 기법** - 가상메모리 사용 , 외부 단편화 해결, 내부 단편화 존재
  
    페이지 단위로 논리-물리 주소 관리 기법입니다. 논리 주소 공간이 하나의 연속적인 물리 메모리 공간에 들어가야하는 제약을 해결하기 위한 기법이며, 논리 주소 공간과 물리 주소 공간을 분리해야하고, 변환을 위한 MMU가 필요합니다. 
  
    - **장점**
  
      1. 외부 단편화 문제 해결
      2. 페이지 공유 가능 : 메모리 공간의 효과적 활용
      3. 페이지 보호 가능
  
    - **단점**
  
      1. 페이지 테이블 사용으로 분할 방식 대비 주소 결속으로 오버헤드 발생 : 속도 저하
  
      2. 페이지가 클수록 내부 단편화는 심해집니다. 
  
          
      
  
  - **세그멘테이션 기법** - 가상메모리 사용, 내부 단편화 해결, 외부 단편화 존재 
  
    - 사용자/프로그래머 관점의 메모리 관리 기법이며, 페이징 기법은 같은 크기의 페이지를 갖는 것과는 다르게 논리적 단위(세그먼트)로 나누므로 미리 분할하는것이 아니고 메모리 사용할 시점에 할당됩니다. 
  
  - **메모리 풀** 
  
    - 필요한 메모리 공간을 필요한 크기, 개수만큼 사용자가 직접 지정하여 미리 할당 받아 놓고 필요할 때마다 사용하고 반납하는 기법입니다.  
    - 메모리 할당, 해제가 잦은 경우에 메모리 풀을 사용하면 효과적이다.
    - 미리 할당해놓고 사용하지 않는 순간에도 계속 할당해놓으므로 메모리 누수가 있는 방식임 



#### 가상메모리

- **가상메모리**란?
  - 메모리에 로드된 실행 중인 프로세스가 메모리가 아닌 가상의 공간을 참조해 마치 커다란 물리 메모리를 갖는 것처럼 사용할 수있게 해주는 기법입니다. 

- **가상 메모리의 역할**은 무엇일까요?
  1. 프로세스에서 실제 메모리 주소를 주는 대신 가상의 메모리 주소를 주는 것입니다.
  2. 가상 메모리는 실제 존재하는 물리 메모리와 사용자 프로세스의 논리 메모리 개념을 분리시킵니다. 
  3. 보조 저장 장치를 마치 RAM 처럼 활용할 수 있습니다. 

- **요구페이징**에 대해 설명하시오
  - 요구페이징은 cpu가 요청할 때 프로세스의 데이터를 메모리에 올리는 것을 의미합니다. 즉 처음부터 모든 데이터를 메모리로 적재하지 않습니다. 
  - 가상 메모리 시스템에서 많이 사용됩니다.
    - 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어옴으로써, 사용되지 않을 페이지를 가져오는 시간과 메모리 낭비를 줄일 수 있습니다.
  - 프리페이징

- cache 메모리를 사용하는 이유에 대해 설명하세요 

  - 먼저 캐시 메모리란 처리 속도가 다른 두 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리 입니다. 
  - 만일 캐시가 존재하지 않는다면 RAM에서 데이터를 인출해오는 속도가 CPU가 태스크를 처리하는 속도보다 느리기 때문에 불필요하게 시간을 낭비해야하지만, 실제로는 중간에 위치한 캐시메모리가 둘 사이에서 데이터를 고속으로 전달해줌으로써 속도 차이로 인한 병목을 어느정도 해결해 줄 수 있습니다. 

  - CPU가 직접 읽는것보다 

  - 램보다 가까이에 위치해있고, 캐시가 램보다 속도 면에서 빠르고, 성능이 좋기때문에 사용한다.  

  - 단점
    - 처리속도가 굉장히 빠른 대신 용량이 작고 비싸다는 치명적인 약점이 존재합니다. 
- 캐시의 지역성 
  - 


#### 커널

- **커널** 이란?

  - **커널은 운영체제 중 항상 메모리에 올라가 있는 운영체제의 핵심 부분으로써 하드웨어와 응용 프로그램 사이에서 인터페이스를 제공하는 역할을 하며 컴퓨터 자원들을 관리하는 역할**을 한다.

  - 커널은 인터페이스로써 응용 프로그램 수행에 필요한 여러가지 서비스를 제공하고, 여러가지 하드웨어 등의 리소스를 관리하는 역할을 한다. 

    

- 커널 수준 스레드와 사용자 수준 스레드의 각각 장단점?

  - **커널 수준 스레드는 스레드 패키지를 운영체제에서 관리하며, 각 응용 프로그램들은 운영체제에 영향을 많이 받게 되므로 이식성이 낮습니다.** 

    - 장점
      - 안정적 
      - 구현이 쉽고, 독자적인 알고리즘이 필요없습니다
    - 단점
      - 문맥 교환이 많이 일어나므로 속도가 느립니다
      - 때문에 대형 시스템에 부적합 합니다.

  - **사용자 수준의 스레드는 스레드 패키지를 사용자 영역에 두고 운영체제 커널은 단일 프로세스만을 관리합니다.** 

    - 장점
      - 문맥 교한이 적으므로 속도가 빠릅니다. 
    - 단점
      - 구현이 어려우며, CPU사용을 해제하지 못하면 시스템이 중단됩니다. 

    

- 인터럽트가 필요한 이유 및 언제 발생되는지 말해주세요

  - CPU가 프로그램을 실행하고 있을때, 입/출력 장치나 혹은 다른 예외 상황이 발생하여 처리가 필요할 경우에 CPU에 알려서 처리를 하기 할때 인터럽트가 발생합니다.  

  - 필요한 이유

    - 입출력 연산은 CPU 명령 수행 속도보다 현저히 느리기 때문에, 상대적으로 속도가 너무 느린 입출력 연산을 CPU가 기다리게 된다면 효율이 너무 떨어지게 됩니다. 그래서 운영체제는 인터럽트로 연산 결과가 나올때까지 CPU에 다른 일을 수행하도록 하고, 연산 작업이 끝나면 작업 완료를 알려 CPU가 다시 해당 작업을 이어서 할 수 있도록 합니다. 즉, **CPU 수행능력을 극대화 하는데 꼭 필요한 기능**입니다. 
    - 인터럽트 예시: 디비전 바이제로, 입출력 오류

  - 외부 인터럽트 : 입출력 오류 

  - 내부 인터럽트 : 디비전 바이제로  

    

- 시스템콜이란 무엇이며 시스템 콜을 사용하는 예시는?

  - **시스템 콜이란 운영체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스 입니다.**  보통 C나 C++과 같은 고급 언어로 작성된 프로그램들은 직접 시스템 호출을 사용 할 수 없기 때문에 고급 API를 통해 시스템 호출에 접근하게 하는 방법입니다. 
  - **일반적으로 윈도우 운영체제라면 마우스가, 리눅스라면 키보드가 사용자로 부터 입력을 받는데, 다음`cp in.txt out.txt`  명령어에서 in.txt 파일을 접근할 수 있는지 검사하기 위해 시스템 콜을 호출합니다.** 만약 파일이 존재하지 않는다면 에러발생, 종료 할 때도 시스템 콜이 사용됩니다
  - 시스템 콜에 주목적 : 커널 접근 

- 커널모드와 유저모드를 구분해 놓은 이유는?

  - 시스템에 중요한 영향을 미치는 연산은 커널 모드에서만 실행 가능하도록 함으로써 하드웨어의 보안을 유지하기 위해서 입니다.

- 서브루틴과 시스템 콜의 차이점은?

  - 서브루틴은 우리가 프로그래밍 할때 사용하는 대부분의 API를 이야기 하는 것입니다. 
  - 서브루틴이 시스템 콜을 호출하며, 시스템 콜이 수행한 결과를 서브루틴으로 보냅니다. 
  - 즉 시스템 콜 호출시 커널이 호출되며, 커널이 수행한 임의의 결과 데이터를 다시 시스템 콜로 보냅니다.
  - 그리고 다시 시스템 콜이 수행한 결과를 서브 루틴으로 보냅니다. 
  - 하지만 실무로 사용할 때는 둘의 큰 차이는 없습니다.  API 를 호출해서 사용하는것을 동일합니다. 